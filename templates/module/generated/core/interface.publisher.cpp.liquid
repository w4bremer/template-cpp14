{% comment %} // Copyright (c) ApiGear UG 2020 {% endcomment -%}
{{ module | licGPLcpp -}}

{% assign class = "I" | append: interface.name | capital %}
{% assign sub_class = class | append: "Subscriber" %}
{% assign pub_class = interface.name | capital | append: "Publisher"%}

#include "{{module.name|identifier}}/generated/core/{{interface.name|lower}}.publisher.h"
#include <algorithm>

{{nl}}
using namespace {{ system.name | capital }}::{{ module.name | capital }};

void {{pub_class}}::subscribeToAllChanges({{sub_class}}& subscriber)
{
    auto found = std::find_if(m_allChangesSubscribers.begin(), m_allChangesSubscribers.end(),
                        [&subscriber](const auto element){return &(element.get()) == &subscriber;});
    if (found == m_allChangesSubscribers.end())
    {
        m_allChangesSubscribers.push_back(std::reference_wrapper<{{sub_class}}>(subscriber));
    }
}
{{nl}}
void {{pub_class}}::unsubscribeFromAllChanges({{sub_class}}& subscriber)
{
    auto found = std::find_if(m_allChangesSubscribers.begin(), m_allChangesSubscribers.end(),
                        [&subscriber](const auto element){return &(element.get()) == &subscriber;});
    if (found != m_allChangesSubscribers.end())
    {
        m_allChangesSubscribers.erase(found);
    }
}
{{nl}}
{% for property in interface.properties %}
long {{pub_class}}::subscribeTo{{property.name|capital}}Changed({{interface.name | capital}}{{property.name | capital}}PropertyCb callback)
{
    auto handleId = m_{{property.name | capital| lowerFirst}}ChangedCallbackNextId++;
    m_{{property.name|capital| lowerFirst}}Callbacks[handleId] = callback;
    return handleId;
}
{{nl}}
void {{pub_class}}::unsubscribeFrom{{property.name | capital}}Changed(long handleId)
{
    m_{{property.name|capital| lowerFirst}}Callbacks.erase(handleId);
}
{{nl}}
void {{pub_class}}::publish{{property.name|capital}}Changed({{property|cpp14Param: true}}) const
{
    for(const auto& subscriber: m_allChangesSubscribers)
    {
        subscriber.get().on{{property.name|capital}}Changed({{property.name}});
    }
    for(const auto& callbackEntry: m_{{property.name|capital| lowerFirst}}Callbacks)
    {
        {% comment %} TODO clean up subscriber if subscriber is not valid anymore {% endcomment %}
        if(callbackEntry.second)
        {
            callbackEntry.second({{property.name}});
        }
    }
}
{{nl}}
{% endfor %}

{% for signal in interface.signals %}
long {{pub_class}}::subscribeTo{{signal.name | capital}}({{interface.name | capital}}{{signal.name | capital}}SignalCb callback)
{
    // this is a short term workaround - we need a better solution for unique handle identifiers
    auto handleId = m_{{signal.name | capital| lowerFirst}}SignalCallbackNextId++;
    m_{{signal.name | capital| lowerFirst}}Callbacks[handleId] = callback;
    return handleId;
}
{{nl}}
void {{pub_class}}::unsubscribeFrom{{signal.name | capital}}(long handleId)
{
    m_{{signal.name | capital| lowerFirst}}Callbacks.erase(handleId);
}
{{nl}}
void {{pub_class}}::publish{{signal.name|capital}}(
    {%- for param in signal.params -%}
        {{param|cpp14Param: true}}{% unless forloop.last %},{% endunless -%}
    {%- endfor -%}
) const
{
    for(const auto& subscriber: m_allChangesSubscribers)
    {
        subscriber.get().on{{signal.name | capital}}(
        {%- for param in signal.params -%}
            {{param.name}}{% unless forloop.last %},{% endunless -%}
        {%- endfor -%}
        );
    }
    for(const auto& callbackEntry: m_{{signal.name|capital| lowerFirst}}Callbacks)
    {
        {% comment %} TODO clean up subscriber if subscriber is not valid anymore {% endcomment %}
        if(callbackEntry.second)
        {
            callbackEntry.second(
            {%- for param in signal.params -%}
                {{param.name}}{% unless forloop.last %},{% endunless -%}
            {%- endfor -%}
            );
        }
    }
}
{{nl}}
{% endfor %}
